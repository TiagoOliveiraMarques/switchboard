# Agent → Proxy authentication (v1)

## Scope

This document specifies how an Agent authenticates to a Proxy instance when establishing and using a tunnel. It is very
important that no agent is able to impersonate another agent running on another machine.

## Goals

- Authenticate a connecting Agent as a specific `agent_id`.
- Prevent an Agent from impersonating another Agent.
- Prevent replay of a previous authentication proof on a new connection.
- Keep the protocol simple and implementable across multiple transports (e.g., TCP, WebSocket, QUIC).

## Non-goals

- End-to-end encryption of webhook payloads beyond transport security (use TLS for that).
- Authorization / routing policy (covered in `proxy-routing.md`).
- Multi-factor or human-in-the-loop authentication.

## Terminology

- **Agent**: Client running on the developer machine.
- **Proxy**: Public-facing Switchboard service.
- **Tunnel**: Persistent Agent ↔ Proxy connection used for bidirectional delivery.
- **`agent_id`**: Stable identifier for an Agent instance used for routing.
- **`key_id`**: Identifier for a public key registered for an `agent_id`.
- **Nonce**: Random, single-use value generated by the Proxy to prevent replay.

## Threat model (v1)

We assume:

- The network is hostile: attackers can observe, delay, replay, and tamper with packets.
- Agents can be compromised; compromise of one agent must not allow impersonation of another agent.
- The Proxy is trusted (but Agents should still connect over TLS and validate the Proxy certificate via normal PKI).

Out of scope for v1 (but worth tracking):

- Key exfiltration from the Agent host (malware) — mitigations depend on OS and key storage.
- Proxy compromise — would expose the registry of agent public keys and allow accepting attacker connections.

## Cryptography

### Signature algorithm

- **Ed25519** signatures (recommended default).
  - **Public key**: 32 bytes
  - **Signature**: 64 bytes

Rationale: modern, fast, widely available, low foot-guns compared to RSA/ECDSA.

### Hashing / encoding

- Nonce is **32 bytes** of cryptographically secure random data, sent as **base64url** without padding.
- All signed material is UTF-8 bytes of a deterministic “string to sign” (defined below).

## Identity and key registry

### Agent identity

Each tunnel connection is identified by an `agent_id`. The `agent_id` is nothing more than a cryptographically secure hash
of the agent's public key. In other words: `agent_id = hex(sha256(public_key_bytes))`.

This makes it impossible for one agent to impersonate another agent unless ones agent private key is leaked.

### Key registry (Proxy-side)

The proxy must maintain a registry with each agent's public key. For performance reasons, it can also store
the agent id (so the sha256 does not need to be constantly computed), but it needs to always make sure both are in sync.

Each key entry has:

- `agent_id` (string)
- `public_key` (Ed25519, 32 bytes; encoded as base64url when serialized)
- `status` in {`active`, `revoked`}
- `created_at` (timestamp)
- `revoked_at` (optional)
- `comment` (optional; operator/debug metadata)

How keys are provisioned to the proxy is an implementation detail that is left for another design document.

### Key registry storage (PostgreSQL)

The proxy SHOULD persist the key registry in PostgreSQL.

Notes:

- `agent_id` is the hex-encoded SHA-256 digest of the raw Ed25519 public key bytes (32 bytes), i.e. `sha256(pubkey)` as a
  64-character lowercase hex string.
- While the protocol/API may transmit the public key as base64url, the DB SHOULD store it as raw bytes (`BYTEA`) to avoid
  accidental encoding mismatches.
- There is exactly **one public key per `agent_id`**, since `agent_id` is derived from the public key.

```sql
-- Registry of allowed agents and their public keys.

-- Enum for key status. (PostgreSQL doesn't support CREATE TYPE IF NOT EXISTS.)
DO $$
BEGIN
  CREATE TYPE agent_key_status AS ENUM ('active', 'revoked');
EXCEPTION
  WHEN duplicate_object THEN NULL;
END
$$;

CREATE TABLE IF NOT EXISTS agent_keys (
  -- 64-char lowercase hex string: sha256(public_key)
  agent_id TEXT PRIMARY KEY
    CHECK (agent_id ~ '^[0-9a-f]{64}$'),

  -- Raw Ed25519 public key bytes (32 bytes).
  public_key BYTEA NOT NULL
    CHECK (octet_length(public_key) = 32),

  -- 'active' keys may authenticate; 'revoked' keys must be rejected.
  status agent_key_status NOT NULL,

  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  revoked_at TIMESTAMPTZ NULL,

  -- Self-consistency: if status is revoked, revoked_at must be set (and vice-versa).
  CHECK ((status = 'revoked') = (revoked_at IS NOT NULL))
);

-- Lookup by agent_id. (PRIMARY KEY also creates a unique btree index on agent_id.)
CREATE UNIQUE INDEX IF NOT EXISTS agent_keys_agent_id_idx ON agent_keys (agent_id);

```

## Authentication handshake (challenge-response)

This handshake happens immediately after the tunnel transport connection is established, and before the Proxy accepts
any authenticated tunnel traffic for routing.

### High-level flow

1. Agent connects to Proxy and begins authentication.
2. Proxy sends a fresh nonce challenge bound to this connection.
3. Agent signs the challenge using its private key and returns proof.
4. Proxy verifies proof using the registered public key for the declared `agent_id`.
5. If verification succeeds, the Proxy marks the connection as authenticated and associates it with `agent_id`.
6. If verification fails, the Proxy MUST close the connection.

### Message transport

This spec is transport-agnostic. Messages can be encoded as JSON frames, protobuf, etc.
For v1, the **normative** structure is the set of fields and the signing input. Implementations MUST preserve the
semantics and determinism of the signing input.

If JSON is used, fields are described below as JSON objects.

### Message: `auth_hello` (Agent → Proxy)

Sent by the Agent to indicate which key it intends to authenticate with.

Fields:

- `type`: `"auth_begin"`
- `v`: `1`
- `agent_id`: unique identifier for this agent - This will identify which public key to use by the proxy for validation.
- `client_time_ms`: integer (Unix epoch millis; optional but recommended)

### Message: `auth_challenge` (Proxy → Agent)

Fields:

- `type`: `"auth_challenge"`
- `v`: `1`
- `nonce`: base64url(32 bytes cryptographically secure random)
- `issued_at_ms`: integer (Unix epoch millis)
- `expires_at_ms`: integer (Unix epoch millis)

Requirements:

- `nonce` MUST be generated by a cryptographically secure RNG.
- `nonce` MUST be unique per issued challenge.
- Proxy MUST associate `challenge_id` with:
  - the underlying connection
  - `agent_id` from `auth_hello`
  - `nonce`, `issued_at_ms`, `expires_at_ms`

Recommended defaults:

- `expires_at_ms = issued_at_ms + 30_000` (30 seconds)

### Message: `auth_proof` (Agent → Proxy)

Fields:

- `type`: `"auth_proof"`
- `v`: `1`
- `agent_id`: string (MUST match `auth_hello.agent_id`)
- `challenge_id`: string (MUST match server-provided id)
- `nonce`: string (MUST match server-provided nonce)
- `issued_at_ms`: integer (MUST match server-provided issued time)
- `signature`: base64url(Ed25519 signature over the “string to sign”)

The Agent MUST NOT send any tunnel messages that require authentication before receiving an explicit success
acknowledgement (below).

### Message: `auth_ok` / `auth_error` (Proxy → Agent)

On success:

- `type`: `"auth_ok"`
- `v`: `1`
- `agent_id`: string
- `authenticated_at_ms`: integer

On failure:

- `type`: `"auth_error"`
- `v`: `1`
- `code`: string (e.g., `unknown_agent`, `unknown_key`, `expired_challenge`, `bad_signature`, `replayed_challenge`)
- `message`: string (human-readable; optional)

After `auth_error`, the Proxy SHOULD close the connection immediately.

## Signing input (normative)

To prevent ambiguity and cross-protocol signature reuse, signatures MUST be computed over the following UTF-8 byte
sequence (the “string to sign”), with `\n` as a literal line-feed character:

```
switchboard-auth-v1
agent_id=<agent_id>
challenge_id=<challenge_id>
nonce=<nonce>
issued_at_ms=<issued_at_ms>
```

Rules:

- The header line MUST be exactly `switchboard-auth-v1`.
- Each field line MUST be present exactly once and in the exact order shown.
- No extra whitespace is permitted.
- New lines should be done with LF character only (no cariage return).
- Values are inserted exactly as sent on the wire for those fields (strings for `agent_id`, `challenge_id`,
  and base64url `nonce`; decimal integer for `issued_at_ms`).

The `signature` is Ed25519 over the full string-to-sign bytes.

## Verification rules (Proxy)

The Proxy accepts authentication if and only if all conditions below hold:

- **Identity lookup**:
  - `agent_id` exists and is allowed to connect.
- **Challenge binding**:
  - `challenge_id` exists and is associated with this same underlying connection.
  - `challenge_id` was issued for the same `agent_id` as in the proof.
  - `nonce` and `issued_at_ms` match the stored challenge values exactly.
- **Freshness**:
  - Current time <= `expires_at_ms`.
  - Challenge has not been used before (single-use).
- **Signature**:
  - Ed25519 signature verification succeeds for the derived string-to-sign.

If accepted:

- Mark the challenge as used.
- Mark the connection as authenticated and bind it to `agent_id`.
- Emit `auth_ok`.

If rejected:

- Emit `auth_error` (optional) and close the connection.
- DO NOT reveal whether an `agent_id` exists via different timings or messages if this matters operationally; at minimum,
  avoid detailed error messages in public logs.

## Replay prevention

Replay is prevented by:

- Unique per-connection nonce challenges.
- Short expiration windows.
- Single-use enforcement of `challenge_id`.
- Binding `challenge_id` to the underlying connection (a proof captured on one connection cannot be replayed on another).

## Connection lifecycle and re-authentication

- Authentication is required **per connection**.
- If the tunnel disconnects, the Agent MUST re-authenticate on reconnect.
- The Proxy MUST treat any unauthenticated connection as untrusted and MUST NOT route webhook traffic to it.

## Key generation, storage, and rotation

### Agent key generation

- Agent generates an Ed25519 keypair on first run.
- Private key MUST be stored securely:
  - Prefer OS-provided secret storage (Windows DPAPI, macOS Keychain, Linux secret service) when available.
  - Avoid storing raw private keys in plaintext on disk.
- Developer is responsible for making sure the proxy has access to a copy of the public key. How that is done (through
API, CLI or admin dashboard), is outside of the scope of this section.

### Key rotation

Key rotation can be done manually in the same way as the first public key was uploaded to the proxy. The developer needs
to generate a new key pair and upload the public key to the proxy storage. How this is done is outside of the scope
of this section.

### Revocation behavior

- If an gent_id is revoked, new authentications using it MUST fail.
- The Proxy SHOULD drop any currently-authenticated connections that were authenticated with a now-revoked
  agent id.

## Operational considerations

- **TLS required**: run the tunnel over TLS; authentication here proves agent identity but does not replace transport
  encryption.
- **Rate limiting**: Proxy SHOULD rate-limit failed auth attempts per source IP and per `agent_id`. The rate limit should
 be configurable.
- **Observability**: log `agent_id`, `key_id`, auth success/failure codes, and connection identifiers for debugging.
- **Clock skew**: since the proxy is authoritative for challenge times, minor agent clock skew is fine; `issued_at_ms` is
  echoed, not generated by the agent.

## Open questions (for iteration)

- What is the tunnel transport (WebSocket, raw TCP, HTTP/2, QUIC), and do we already have a framing layer for messages?
- How are public keys provisioned to the Proxy (config file, DB, onboarding API), and who/what is allowed to register a
  new key for an `agent_id`?
- Is there a higher-level “account / developer / workspace” identity that owns one or more `agent_id`s?
- Should we require mutual authentication beyond normal TLS PKI (e.g., pin proxy key, or add an optional proxy proof)?
